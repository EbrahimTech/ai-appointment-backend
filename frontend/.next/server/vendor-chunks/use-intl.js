"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-intl";
exports.ids = ["vendor-chunks/use-intl"];
exports.modules = {

/***/ "(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ IntlError),\n/* harmony export */   a: () => (/* binding */ IntlErrorCode),\n/* harmony export */   b: () => (/* binding */ createIntlFormatters),\n/* harmony export */   c: () => (/* binding */ createFormatter),\n/* harmony export */   d: () => (/* binding */ createCache),\n/* harmony export */   e: () => (/* binding */ createBaseTranslator),\n/* harmony export */   f: () => (/* binding */ defaultGetMessageFallback),\n/* harmony export */   g: () => (/* binding */ defaultOnError),\n/* harmony export */   i: () => (/* binding */ initializeConfig),\n/* harmony export */   r: () => (/* binding */ resolveNamespace)\n/* harmony export */ });\n/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/src/core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formatjs/fast-memoize */ \"(ssr)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\n\n\n\nclass IntlError extends Error {\n    constructor(code, originalMessage){\n        let message = code;\n        if (originalMessage) {\n            message += \": \" + originalMessage;\n        }\n        super(message);\n        this.code = code;\n        if (originalMessage) {\n            this.originalMessage = originalMessage;\n        }\n    }\n}\nvar IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {\n    IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n    IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n    IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n    IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n    IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n    IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n    IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n    return IntlErrorCode;\n}(IntlErrorCode || {});\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */ function convertFormatsToIntlMessageFormat(globalFormats, inlineFormats, timeZone) {\n    const mfDateDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.date;\n    const mfTimeDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.time;\n    const dateTimeFormats = {\n        ...globalFormats?.dateTime,\n        ...inlineFormats?.dateTime\n    };\n    const allFormats = {\n        date: {\n            ...mfDateDefaults,\n            ...dateTimeFormats\n        },\n        time: {\n            ...mfTimeDefaults,\n            ...dateTimeFormats\n        },\n        number: {\n            ...globalFormats?.number,\n            ...inlineFormats?.number\n        }\n    };\n    if (timeZone) {\n        // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n        // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n        [\n            \"date\",\n            \"time\"\n        ].forEach((property)=>{\n            const formats = allFormats[property];\n            for (const [key, value] of Object.entries(formats)){\n                formats[key] = {\n                    timeZone,\n                    ...value\n                };\n            }\n        });\n    }\n    return allFormats;\n}\nfunction joinPath(...parts) {\n    return parts.filter(Boolean).join(\".\");\n}\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */ function defaultGetMessageFallback(props) {\n    return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n    console.error(error);\n}\nfunction createCache() {\n    return {\n        dateTime: {},\n        number: {},\n        message: {},\n        relativeTime: {},\n        pluralRules: {},\n        list: {},\n        displayNames: {}\n    };\n}\nfunction createMemoCache(store) {\n    return {\n        create () {\n            return {\n                get (key) {\n                    return store[key];\n                },\n                set (key, value) {\n                    store[key] = value;\n                }\n            };\n        }\n    };\n}\nfunction memoFn(fn, cache) {\n    return (0,_formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(fn, {\n        cache: createMemoCache(cache),\n        strategy: _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.strategies.variadic\n    });\n}\nfunction memoConstructor(ConstructorFn, cache) {\n    return memoFn((...args)=>new ConstructorFn(...args), cache);\n}\nfunction createIntlFormatters(cache) {\n    const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);\n    const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);\n    const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);\n    const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);\n    const getListFormat = memoConstructor(Intl.ListFormat, cache.list);\n    const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);\n    return {\n        getDateTimeFormat,\n        getNumberFormat,\n        getPluralRules,\n        getRelativeTimeFormat,\n        getListFormat,\n        getDisplayNames\n    };\n}\n// Placed here for improved tree shaking. Somehow when this is placed in\n// `formatters.tsx`, then it can't be shaken off from `next-intl`.\nfunction createMessageFormatter(cache, intlFormatters) {\n    const getMessageFormat = memoFn((...args)=>new intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat(args[0], args[1], args[2], {\n            formatters: intlFormatters,\n            ...args[3]\n        }), cache.message);\n    return getMessageFormat;\n}\nfunction resolvePath(locale, messages, key, namespace) {\n    const fullKey = joinPath(namespace, key);\n    if (!messages) {\n        throw new Error(`No messages available at \\`${namespace}\\`.`);\n    }\n    let message = messages;\n    key.split(\".\").forEach((part)=>{\n        const next = message[part];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (part == null || next == null) {\n            throw new Error(`Could not resolve \\`${fullKey}\\` in messages for locale \\`${locale}\\`.`);\n        }\n        message = next;\n    });\n    return message;\n}\nfunction prepareTranslationValues(values) {\n    // Workaround for https://github.com/formatjs/formatjs/issues/1467\n    const transformedValues = {};\n    Object.keys(values).forEach((key)=>{\n        let index = 0;\n        const value = values[key];\n        let transformed;\n        if (typeof value === \"function\") {\n            transformed = (chunks)=>{\n                const result = value(chunks);\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(result) ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(result, {\n                    key: key + index++\n                }) : result;\n            };\n        } else {\n            transformed = value;\n        }\n        transformedValues[key] = transformed;\n    });\n    return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace) {\n    try {\n        if (!messages) {\n            throw new Error(`No messages were configured.`);\n        }\n        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!retrievedMessages) {\n            throw new Error(`No messages for namespace \\`${namespace}\\` found.`);\n        }\n        return retrievedMessages;\n    } catch (error) {\n        const intlError = new IntlError(IntlErrorCode.MISSING_MESSAGE, error.message);\n        return intlError;\n    }\n}\nfunction getPlainMessage(candidate, values) {\n    // To improve runtime performance, only compile message if:\n    return(// 1. Values are provided\n    values || // 2. There are escaped braces (e.g. \"'{name'}\")\n    /'[{}]/.test(candidate) || // 3. There are missing arguments or tags (dev-only error handling)\n    /<|{/.test(candidate) ? undefined // Compile\n     : candidate // Don't compile\n    );\n}\nfunction createBaseTranslator(config) {\n    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace);\n    return createBaseTranslatorImpl({\n        ...config,\n        messagesOrError\n    });\n}\nfunction createBaseTranslatorImpl({ cache, formats: globalFormats, formatters, getMessageFallback = defaultGetMessageFallback, locale, messagesOrError, namespace, onError, timeZone }) {\n    const hasMessagesError = messagesOrError instanceof IntlError;\n    function getFallbackFromErrorAndNotify(key, code, message, fallback) {\n        const error = new IntlError(code, message);\n        onError(error);\n        return fallback ?? getMessageFallback({\n            error,\n            key,\n            namespace\n        });\n    }\n    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats, _fallback) {\n        const fallback = _fallback;\n        let message;\n        if (hasMessagesError) {\n            if (fallback) {\n                message = fallback;\n            } else {\n                onError(messagesOrError);\n                return getMessageFallback({\n                    error: messagesOrError,\n                    key,\n                    namespace\n                });\n            }\n        } else {\n            const messages = messagesOrError;\n            try {\n                message = resolvePath(locale, messages, key, namespace);\n            } catch (error) {\n                if (fallback) {\n                    message = fallback;\n                } else {\n                    return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message, fallback);\n                }\n            }\n        }\n        if (typeof message === \"object\") {\n            let code, errorMessage;\n            if (Array.isArray(message)) {\n                code = IntlErrorCode.INVALID_MESSAGE;\n                {\n                    errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/translations#arrays-of-messages`;\n                }\n            } else {\n                code = IntlErrorCode.INSUFFICIENT_PATH;\n                {\n                    errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl.dev/docs/usage/translations#structuring-messages`;\n                }\n            }\n            return getFallbackFromErrorAndNotify(key, code, errorMessage);\n        }\n        let messageFormat;\n        // Hot path that avoids creating an `IntlMessageFormat` instance\n        const plainMessage = getPlainMessage(message, values);\n        if (plainMessage) return plainMessage;\n        // Lazy init the message formatter for better tree\n        // shaking in case message formatting is not used.\n        if (!formatters.getMessageFormat) {\n            formatters.getMessageFormat = createMessageFormatter(cache, formatters);\n        }\n        try {\n            messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat(globalFormats, formats, timeZone), {\n                formatters: {\n                    ...formatters,\n                    getDateTimeFormat (locales, options) {\n                        // Workaround for https://github.com/formatjs/formatjs/issues/4279\n                        return formatters.getDateTimeFormat(locales, {\n                            timeZone,\n                            ...options\n                        });\n                    }\n                }\n            });\n        } catch (error) {\n            const thrownError = error;\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, thrownError.message + (\"originalMessage\" in thrownError ? ` (${thrownError.originalMessage})` : \"\"), fallback);\n        }\n        try {\n            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format\n            // for rich text elements since a recent minor update. This\n            // needs to be evaluated in detail, possibly also in regards\n            // to be able to format to parts.\n            values ? prepareTranslationValues(values) : values);\n            if (formattedMessage == null) {\n                throw new Error(`Unable to format \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : \"messages\"}`);\n            }\n            // Limit the function signature to return strings or React elements\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(formattedMessage) || // Arrays of React elements\n            Array.isArray(formattedMessage) || typeof formattedMessage === \"string\" ? formattedMessage : String(formattedMessage);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.FORMATTING_ERROR, error.message, fallback);\n        }\n    }\n    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Custom formats for numbers, dates and times. */ formats, _fallback) {\n        const result = translateBaseFn(key, values, formats, _fallback);\n        if (typeof result !== \"string\") {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, `The message \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : \"messages\"} didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`);\n        }\n        return result;\n    }\n    translateFn.rich = translateBaseFn;\n    // Augment `translateBaseFn` to return plain strings\n    translateFn.markup = (key, values, formats, _fallback)=>{\n        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n        // of `RichTranslationValues` but TypeScript isn't smart enough here.\n        values, formats, _fallback);\n        if (typeof result !== \"string\") {\n            const error = new IntlError(IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n            onError(error);\n            return getMessageFallback({\n                error,\n                key,\n                namespace\n            });\n        }\n        return result;\n    };\n    translateFn.raw = (key)=>{\n        if (hasMessagesError) {\n            onError(messagesOrError);\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        try {\n            return resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n    };\n    translateFn.has = (key)=>{\n        if (hasMessagesError) {\n            return false;\n        }\n        try {\n            resolvePath(locale, messagesOrError, key, namespace);\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n    return translateFn;\n}\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */ function resolveNamespace(namespace, namespacePrefix) {\n    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + \".\").length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n    second: SECOND,\n    seconds: SECOND,\n    minute: MINUTE,\n    minutes: MINUTE,\n    hour: HOUR,\n    hours: HOUR,\n    day: DAY,\n    days: DAY,\n    week: WEEK,\n    weeks: WEEK,\n    month: MONTH,\n    months: MONTH,\n    quarter: QUARTER,\n    quarters: QUARTER,\n    year: YEAR,\n    years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n    const absValue = Math.abs(seconds);\n    if (absValue < MINUTE) {\n        return \"second\";\n    } else if (absValue < HOUR) {\n        return \"minute\";\n    } else if (absValue < DAY) {\n        return \"hour\";\n    } else if (absValue < WEEK) {\n        return \"day\";\n    } else if (absValue < MONTH) {\n        return \"week\";\n    } else if (absValue < YEAR) {\n        return \"month\";\n    }\n    return \"year\";\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n    // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n    // will include fractions like '2.1 hours ago'.\n    return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(props) {\n    const { _cache: cache = createCache(), _formatters: formatters = createIntlFormatters(cache), formats, locale, onError = defaultOnError, timeZone: globalTimeZone } = props;\n    function applyTimeZone(options) {\n        if (!options?.timeZone) {\n            if (globalTimeZone) {\n                options = {\n                    ...options,\n                    timeZone: globalTimeZone\n                };\n            } else {\n                onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`timeZone\\` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone`));\n            }\n        }\n        return options;\n    }\n    function resolveFormatOrOptions(typeFormats, formatOrOptions, overrides) {\n        let options;\n        if (typeof formatOrOptions === \"string\") {\n            const formatName = formatOrOptions;\n            options = typeFormats?.[formatName];\n            if (!options) {\n                const error = new IntlError(IntlErrorCode.MISSING_FORMAT, `Format \\`${formatName}\\` is not available.`);\n                onError(error);\n                throw error;\n            }\n        } else {\n            options = formatOrOptions;\n        }\n        if (overrides) {\n            options = {\n                ...options,\n                ...overrides\n            };\n        }\n        return options;\n    }\n    function getFormattedValue(formatOrOptions, overrides, typeFormats, formatter, getFallback) {\n        let options;\n        try {\n            options = resolveFormatOrOptions(typeFormats, formatOrOptions, overrides);\n        } catch  {\n            return getFallback();\n        }\n        try {\n            return formatter(options);\n        } catch (error) {\n            onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n            return getFallback();\n        }\n    }\n    function dateTime(value, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).format(value);\n        }, ()=>String(value));\n    }\n    function dateTimeRange(start, end, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).formatRange(start, end);\n        }, ()=>[\n                dateTime(start),\n                dateTime(end)\n            ].join(\" – \"));\n    }\n    function number(value, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.number, (options)=>formatters.getNumberFormat(locale, options).format(value), ()=>String(value));\n    }\n    function getGlobalNow() {\n        // Only read when necessary to avoid triggering a `dynamicIO` error\n        // unnecessarily (`now` is only needed for `format.relativeTime`)\n        if (props.now) {\n            return props.now;\n        } else {\n            onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`now\\` parameter wasn't provided to \\`relativeTime\\` and there is no global default configured, therefore the current time will be used as a fallback. See https://next-intl.dev/docs/usage/dates-times#relative-times-usenow`));\n            return new Date();\n        }\n    }\n    function relativeTime(date, nowOrOptions) {\n        try {\n            let nowDate, unit;\n            const opts = {};\n            if (nowOrOptions instanceof Date || typeof nowOrOptions === \"number\") {\n                nowDate = new Date(nowOrOptions);\n            } else if (nowOrOptions) {\n                if (nowOrOptions.now != null) {\n                    nowDate = new Date(nowOrOptions.now);\n                } else {\n                    nowDate = getGlobalNow();\n                }\n                unit = nowOrOptions.unit;\n                opts.style = nowOrOptions.style;\n                // @ts-expect-error -- Types are slightly outdated\n                opts.numberingSystem = nowOrOptions.numberingSystem;\n            }\n            if (!nowDate) {\n                nowDate = getGlobalNow();\n            }\n            const dateDate = new Date(date);\n            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n            if (!unit) {\n                unit = resolveRelativeTimeUnit(seconds);\n            }\n            // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n            // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n            // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n            // not desired, as the given dates might cross a threshold were the\n            // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n            // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n            // case. By using `always` we can ensure correct output. The only exception\n            // is the formatting of times <1 second as \"now\".\n            opts.numeric = unit === \"second\" ? \"auto\" : \"always\";\n            const value = calculateRelativeTimeValue(seconds, unit);\n            return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);\n        } catch (error) {\n            onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n            return String(date);\n        }\n    }\n    function list(value, formatOrOptions, overrides) {\n        const serializedValue = [];\n        const richValues = new Map();\n        // `formatToParts` only accepts strings, therefore we have to temporarily\n        // replace React elements with a placeholder ID that can be used to retrieve\n        // the original value afterwards.\n        let index = 0;\n        for (const item of value){\n            let serializedItem;\n            if (typeof item === \"object\") {\n                serializedItem = String(index);\n                richValues.set(serializedItem, item);\n            } else {\n                serializedItem = String(item);\n            }\n            serializedValue.push(serializedItem);\n            index++;\n        }\n        return getFormattedValue(formatOrOptions, overrides, formats?.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n        (options)=>{\n            const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === \"literal\" ? part.value : richValues.get(part.value) || part.value);\n            if (richValues.size > 0) {\n                return result;\n            } else {\n                return result.join(\"\");\n            }\n        }, ()=>String(value));\n    }\n    return {\n        dateTime,\n        number,\n        relativeTime,\n        list,\n        dateTimeRange\n    };\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n    Object.entries(messages).forEach(([key, messageOrMessages])=>{\n        if (key.includes(\".\")) {\n            let keyLabel = key;\n            if (parentPath) keyLabel += ` (at ${parentPath})`;\n            invalidKeyLabels.push(keyLabel);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (messageOrMessages != null && typeof messageOrMessages === \"object\") {\n            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n        }\n    });\n}\nfunction validateMessages(messages, onError) {\n    const invalidKeyLabels = [];\n    validateMessagesSegment(messages, invalidKeyLabels);\n    if (invalidKeyLabels.length > 0) {\n        onError(new IntlError(IntlErrorCode.INVALID_KEY, `Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid ${invalidKeyLabels.length === 1 ? \"key\" : \"keys\"}: ${invalidKeyLabels.join(\", \")}\n\nIf you're migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from \"lodash\";\n\nconst input = {\n  \"one.one\": \"1.1\",\n  \"one.two\": \"1.2\",\n  \"two.one.one\": \"2.1.1\"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   \"one\": {\n//     \"one\": \"1.1\",\n//     \"two\": \"1.2\"\n//   },\n//   \"two\": {\n//     \"one\": {\n//       \"one\": \"2.1.1\"\n//     }\n//   }\n// }\n`));\n    }\n}\n/**\n * Enhances the incoming props with defaults.\n */ function initializeConfig({ formats, getMessageFallback, messages, onError, ...rest }) {\n    const finalOnError = onError || defaultOnError;\n    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n    {\n        if (messages) {\n            validateMessages(messages, finalOnError);\n        }\n    }\n    return {\n        ...rest,\n        formats: formats || undefined,\n        messages: messages || undefined,\n        onError: finalOnError,\n        getMessageFallback: finalGetMessageFallback\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvaW5pdGlhbGl6ZUNvbmZpZy1DSURWTVMyRS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ0Y7QUFDUTtBQUU3RCxNQUFNSyxrQkFBa0JDO0lBQ3RCQyxZQUFZQyxJQUFJLEVBQUVDLGVBQWUsQ0FBRTtRQUNqQyxJQUFJQyxVQUFVRjtRQUNkLElBQUlDLGlCQUFpQjtZQUNuQkMsV0FBVyxPQUFPRDtRQUNwQjtRQUNBLEtBQUssQ0FBQ0M7UUFDTixJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJQyxpQkFBaUI7WUFDbkIsSUFBSSxDQUFDQSxlQUFlLEdBQUdBO1FBQ3pCO0lBQ0Y7QUFDRjtBQUVBLElBQUlFLGdCQUFnQixXQUFXLEdBQUUsU0FBVUEsYUFBYTtJQUN0REEsYUFBYSxDQUFDLGtCQUFrQixHQUFHO0lBQ25DQSxhQUFhLENBQUMsaUJBQWlCLEdBQUc7SUFDbENBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJQUN4Q0EsYUFBYSxDQUFDLG9CQUFvQixHQUFHO0lBQ3JDQSxhQUFhLENBQUMsa0JBQWtCLEdBQUc7SUFDbkNBLGFBQWEsQ0FBQyxjQUFjLEdBQUc7SUFDL0JBLGFBQWEsQ0FBQyxtQkFBbUIsR0FBRztJQUNwQyxPQUFPQTtBQUNULEVBQUVBLGlCQUFpQixDQUFDO0FBRXBCOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGtDQUFrQ0MsYUFBYSxFQUFFQyxhQUFhLEVBQUVDLFFBQVE7SUFDL0UsTUFBTUMsaUJBQWlCaEIsaUVBQWlCQSxDQUFDaUIsT0FBTyxDQUFDQyxJQUFJO0lBQ3JELE1BQU1DLGlCQUFpQm5CLGlFQUFpQkEsQ0FBQ2lCLE9BQU8sQ0FBQ0csSUFBSTtJQUNyRCxNQUFNQyxrQkFBa0I7UUFDdEIsR0FBR1IsZUFBZVMsUUFBUTtRQUMxQixHQUFHUixlQUFlUSxRQUFRO0lBQzVCO0lBQ0EsTUFBTUMsYUFBYTtRQUNqQkws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Q3RCO0FBQ0Y7QUFFK08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1hcHBvaW50bWVudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2VzbS9kZXZlbG9wbWVudC9pbml0aWFsaXplQ29uZmlnLUNJRFZNUzJFLmpzP2E3M2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW50bE1lc3NhZ2VGb3JtYXQgfSBmcm9tICdpbnRsLW1lc3NhZ2Vmb3JtYXQnO1xuaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnQsIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG1lbW9pemUsIHN0cmF0ZWdpZXMgfSBmcm9tICdAZm9ybWF0anMvZmFzdC1tZW1vaXplJztcblxuY2xhc3MgSW50bEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGNvZGU7XG4gICAgaWYgKG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSArPSAnOiAnICsgb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgfVxufVxuXG52YXIgSW50bEVycm9yQ29kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoSW50bEVycm9yQ29kZSkge1xuICBJbnRsRXJyb3JDb2RlW1wiTUlTU0lOR19NRVNTQUdFXCJdID0gXCJNSVNTSU5HX01FU1NBR0VcIjtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfRk9STUFUXCJdID0gXCJNSVNTSU5HX0ZPUk1BVFwiO1xuICBJbnRsRXJyb3JDb2RlW1wiRU5WSVJPTk1FTlRfRkFMTEJBQ0tcIl0gPSBcIkVOVklST05NRU5UX0ZBTExCQUNLXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfUEFUSFwiXSA9IFwiSU5TVUZGSUNJRU5UX1BBVEhcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOVkFMSURfTUVTU0FHRVwiXSA9IFwiSU5WQUxJRF9NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX0tFWVwiXSA9IFwiSU5WQUxJRF9LRVlcIjtcbiAgSW50bEVycm9yQ29kZVtcIkZPUk1BVFRJTkdfRVJST1JcIl0gPSBcIkZPUk1BVFRJTkdfRVJST1JcIjtcbiAgcmV0dXJuIEludGxFcnJvckNvZGU7XG59KEludGxFcnJvckNvZGUgfHwge30pO1xuXG4vKipcbiAqIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIHVzZXMgc2VwYXJhdGUga2V5cyBmb3IgYGRhdGVgIGFuZCBgdGltZWAsIGJ1dCB0aGVyZSdzXG4gKiBvbmx5IG9uZSBuYXRpdmUgQVBJOiBgSW50bC5EYXRlVGltZUZvcm1hdGAuIEFkZGl0aW9uYWxseSB5b3UgbWlnaHQgd2FudCB0b1xuICogaW5jbHVkZSBib3RoIGEgdGltZSBhbmQgYSBkYXRlIGluIGEgdmFsdWUsIHRoZXJlZm9yZSB0aGUgc2VwYXJhdGlvbiBkb2Vzbid0XG4gKiBzZWVtIHNvIHVzZWZ1bC4gV2Ugb2ZmZXIgYSBzaW5nbGUgYGRhdGVUaW1lYCBuYW1lc3BhY2UgaW5zdGVhZCwgYnV0IHdlIGhhdmVcbiAqIHRvIGNvbnZlcnQgdGhlIGZvcm1hdCBiZWZvcmUgYGludGwtbWVzc2FnZWZvcm1hdGAgY2FuIGJlIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChnbG9iYWxGb3JtYXRzLCBpbmxpbmVGb3JtYXRzLCB0aW1lWm9uZSkge1xuICBjb25zdCBtZkRhdGVEZWZhdWx0cyA9IEludGxNZXNzYWdlRm9ybWF0LmZvcm1hdHMuZGF0ZTtcbiAgY29uc3QgbWZUaW1lRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdC5mb3JtYXRzLnRpbWU7XG4gIGNvbnN0IGRhdGVUaW1lRm9ybWF0cyA9IHtcbiAgICAuLi5nbG9iYWxGb3JtYXRzPy5kYXRlVGltZSxcbiAgICAuLi5pbmxpbmVGb3JtYXRzPy5kYXRlVGltZVxuICB9O1xuICBjb25zdCBhbGxGb3JtYXRzID0ge1xuICAgIGRhdGU6IHtcbiAgICAgIC4uLm1mRGF0ZURlZmF1bHRzLFxuICAgICAgLi4uZGF0ZVRpbWVGb3JtYXRzXG4gICAgfSxcbiAgICB0aW1lOiB7XG4gICAgICAuLi5tZlRpbWVEZWZhdWx0cyxcbiAgICAgIC4uLmRhdGVUaW1lRm9ybWF0c1xuICAgIH0sXG4gICAgbnVtYmVyOiB7XG4gICAgICAuLi5nbG9iYWxGb3JtYXRzPy5udW1iZXIsXG4gICAgICAuLi5pbmxpbmVGb3JtYXRzPy5udW1iZXJcbiAgICB9XG4gICAgLy8gKGxpc3QgaXMgbm90IHN1cHBvcnRlZCBpbiBJQ1UgbWVzc2FnZXMpXG4gIH07XG4gIGlmICh0aW1lWm9uZSkge1xuICAgIC8vIFRoZSBvbmx5IHdheSB0byBzZXQgYSB0aW1lIHpvbmUgd2l0aCBgaW50bC1tZXNzYWdlZm9ybWF0YCBpcyB0byBtZXJnZSBpdCBpbnRvIHRoZSBmb3JtYXRzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2Jsb2IvODI1NmM1MjcxNTA1Y2YyNjA2ZTQ4ZTNjOTdlY2RkMTZlZGU0ZjFiNS9wYWNrYWdlcy9pbnRsL3NyYy9tZXNzYWdlLnRzI0wxNVxuICAgIFsnZGF0ZScsICd0aW1lJ10uZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXRzID0gYWxsRm9ybWF0c1twcm9wZXJ0eV07XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmb3JtYXRzKSkge1xuICAgICAgICBmb3JtYXRzW2tleV0gPSB7XG4gICAgICAgICAgdGltZVpvbmUsXG4gICAgICAgICAgLi4udmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYWxsRm9ybWF0cztcbn1cblxuZnVuY3Rpb24gam9pblBhdGgoLi4ucGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLmZpbHRlcihCb29sZWFuKS5qb2luKCcuJyk7XG59XG5cbi8qKlxuICogQ29udGFpbnMgZGVmYXVsdHMgdGhhdCBhcmUgdXNlZCBmb3IgYWxsIGVudHJ5IHBvaW50cyBpbnRvIHRoZSBjb3JlLlxuICogU2VlIGFsc28gYEluaXRpYWxpemVkSW50bENvbmZpZ3VyYXRpb25gLlxuICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2socHJvcHMpIHtcbiAgcmV0dXJuIGpvaW5QYXRoKHByb3BzLm5hbWVzcGFjZSwgcHJvcHMua2V5KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZToge30sXG4gICAgbnVtYmVyOiB7fSxcbiAgICBtZXNzYWdlOiB7fSxcbiAgICByZWxhdGl2ZVRpbWU6IHt9LFxuICAgIHBsdXJhbFJ1bGVzOiB7fSxcbiAgICBsaXN0OiB7fSxcbiAgICBkaXNwbGF5TmFtZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVNZW1vQ2FjaGUoc3RvcmUpIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9GbihmbiwgY2FjaGUpIHtcbiAgcmV0dXJuIG1lbW9pemUoZm4sIHtcbiAgICBjYWNoZTogY3JlYXRlTWVtb0NhY2hlKGNhY2hlKSxcbiAgICBzdHJhdGVneTogc3RyYXRlZ2llcy52YXJpYWRpY1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1lbW9Db25zdHJ1Y3RvcihDb25zdHJ1Y3RvckZuLCBjYWNoZSkge1xuICByZXR1cm4gbWVtb0ZuKCguLi5hcmdzKSA9PiBuZXcgQ29uc3RydWN0b3JGbiguLi5hcmdzKSwgY2FjaGUpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpIHtcbiAgY29uc3QgZ2V0RGF0ZVRpbWVGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5EYXRlVGltZUZvcm1hdCwgY2FjaGUuZGF0ZVRpbWUpO1xuICBjb25zdCBnZXROdW1iZXJGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5OdW1iZXJGb3JtYXQsIGNhY2hlLm51bWJlcik7XG4gIGNvbnN0IGdldFBsdXJhbFJ1bGVzID0gbWVtb0NvbnN0cnVjdG9yKEludGwuUGx1cmFsUnVsZXMsIGNhY2hlLnBsdXJhbFJ1bGVzKTtcbiAgY29uc3QgZ2V0UmVsYXRpdmVUaW1lRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LCBjYWNoZS5yZWxhdGl2ZVRpbWUpO1xuICBjb25zdCBnZXRMaXN0Rm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuTGlzdEZvcm1hdCwgY2FjaGUubGlzdCk7XG4gIGNvbnN0IGdldERpc3BsYXlOYW1lcyA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkRpc3BsYXlOYW1lcywgY2FjaGUuZGlzcGxheU5hbWVzKTtcbiAgcmV0dXJuIHtcbiAgICBnZXREYXRlVGltZUZvcm1hdCxcbiAgICBnZXROdW1iZXJGb3JtYXQsXG4gICAgZ2V0UGx1cmFsUnVsZXMsXG4gICAgZ2V0UmVsYXRpdmVUaW1lRm9ybWF0LFxuICAgIGdldExpc3RGb3JtYXQsXG4gICAgZ2V0RGlzcGxheU5hbWVzXG4gIH07XG59XG5cbi8vIFBsYWNlZCBoZXJlIGZvciBpbXByb3ZlZCB0cmVlIHNoYWtpbmcuIFNvbWVob3cgd2hlbiB0aGlzIGlzIHBsYWNlZCBpblxuLy8gYGZvcm1hdHRlcnMudHN4YCwgdGhlbiBpdCBjYW4ndCBiZSBzaGFrZW4gb2ZmIGZyb20gYG5leHQtaW50bGAuXG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlRm9ybWF0dGVyKGNhY2hlLCBpbnRsRm9ybWF0dGVycykge1xuICBjb25zdCBnZXRNZXNzYWdlRm9ybWF0ID0gbWVtb0ZuKCguLi5hcmdzKSA9PiBuZXcgSW50bE1lc3NhZ2VGb3JtYXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwge1xuICAgIGZvcm1hdHRlcnM6IGludGxGb3JtYXR0ZXJzLFxuICAgIC4uLmFyZ3NbM11cbiAgfSksIGNhY2hlLm1lc3NhZ2UpO1xuICByZXR1cm4gZ2V0TWVzc2FnZUZvcm1hdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IGZ1bGxLZXkgPSBqb2luUGF0aChuYW1lc3BhY2UsIGtleSk7XG4gIGlmICghbWVzc2FnZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIGF2YWlsYWJsZSBhdCBcXGAke25hbWVzcGFjZX1cXGAuYCApO1xuICB9XG4gIGxldCBtZXNzYWdlID0gbWVzc2FnZXM7XG4gIGtleS5zcGxpdCgnLicpLmZvckVhY2gocGFydCA9PiB7XG4gICAgY29uc3QgbmV4dCA9IG1lc3NhZ2VbcGFydF07XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmIChwYXJ0ID09IG51bGwgfHwgbmV4dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXNvbHZlIFxcYCR7ZnVsbEtleX1cXGAgaW4gbWVzc2FnZXMgZm9yIGxvY2FsZSBcXGAke2xvY2FsZX1cXGAuYCApO1xuICAgIH1cbiAgICBtZXNzYWdlID0gbmV4dDtcbiAgfSk7XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gcHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzKHZhbHVlcykge1xuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzE0NjdcbiAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZXMgPSB7fTtcbiAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgIGxldCB0cmFuc2Zvcm1lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IGNodW5rcyA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlKGNodW5rcyk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovaXNWYWxpZEVsZW1lbnQocmVzdWx0KSA/IC8qI19fUFVSRV9fKi9jbG9uZUVsZW1lbnQocmVzdWx0LCB7XG4gICAgICAgICAga2V5OiBrZXkgKyBpbmRleCsrXG4gICAgICAgIH0pIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgdHJhbnNmb3JtZWRWYWx1ZXNba2V5XSA9IHRyYW5zZm9ybWVkO1xuICB9KTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVkVmFsdWVzO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZXNPckVycm9yKGxvY2FsZSwgbWVzc2FnZXMsIG5hbWVzcGFjZSkge1xuICB0cnkge1xuICAgIGlmICghbWVzc2FnZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWVzc2FnZXMgd2VyZSBjb25maWd1cmVkLmAgKTtcbiAgICB9XG4gICAgY29uc3QgcmV0cmlldmVkTWVzc2FnZXMgPSBuYW1lc3BhY2UgPyByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBuYW1lc3BhY2UpIDogbWVzc2FnZXM7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmICghcmV0cmlldmVkTWVzc2FnZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWVzc2FnZXMgZm9yIG5hbWVzcGFjZSBcXGAke25hbWVzcGFjZX1cXGAgZm91bmQuYCApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0cmlldmVkTWVzc2FnZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgaW50bEVycm9yID0gbmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgcmV0dXJuIGludGxFcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGxhaW5NZXNzYWdlKGNhbmRpZGF0ZSwgdmFsdWVzKSB7XG4gIC8vIFRvIGltcHJvdmUgcnVudGltZSBwZXJmb3JtYW5jZSwgb25seSBjb21waWxlIG1lc3NhZ2UgaWY6XG4gIHJldHVybiAoXG4gICAgLy8gMS4gVmFsdWVzIGFyZSBwcm92aWRlZFxuICAgIHZhbHVlcyB8fFxuICAgIC8vIDIuIFRoZXJlIGFyZSBlc2NhcGVkIGJyYWNlcyAoZS5nLiBcIid7bmFtZSd9XCIpXG4gICAgLydbe31dLy50ZXN0KGNhbmRpZGF0ZSkgfHxcbiAgICAvLyAzLiBUaGVyZSBhcmUgbWlzc2luZyBhcmd1bWVudHMgb3IgdGFncyAoZGV2LW9ubHkgZXJyb3IgaGFuZGxpbmcpXG4gICAgLzx8ey8udGVzdChjYW5kaWRhdGUpID8gdW5kZWZpbmVkIC8vIENvbXBpbGVcbiAgICA6IGNhbmRpZGF0ZSAvLyBEb24ndCBjb21waWxlXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvcihjb25maWcpIHtcbiAgY29uc3QgbWVzc2FnZXNPckVycm9yID0gZ2V0TWVzc2FnZXNPckVycm9yKGNvbmZpZy5sb2NhbGUsIGNvbmZpZy5tZXNzYWdlcywgY29uZmlnLm5hbWVzcGFjZSk7XG4gIHJldHVybiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoe1xuICAgIC4uLmNvbmZpZyxcbiAgICBtZXNzYWdlc09yRXJyb3JcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoe1xuICBjYWNoZSxcbiAgZm9ybWF0czogZ2xvYmFsRm9ybWF0cyxcbiAgZm9ybWF0dGVycyxcbiAgZ2V0TWVzc2FnZUZhbGxiYWNrID0gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayxcbiAgbG9jYWxlLFxuICBtZXNzYWdlc09yRXJyb3IsXG4gIG5hbWVzcGFjZSxcbiAgb25FcnJvcixcbiAgdGltZVpvbmVcbn0pIHtcbiAgY29uc3QgaGFzTWVzc2FnZXNFcnJvciA9IG1lc3NhZ2VzT3JFcnJvciBpbnN0YW5jZW9mIEludGxFcnJvcjtcbiAgZnVuY3Rpb24gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBtZXNzYWdlLCBmYWxsYmFjaykge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEludGxFcnJvcihjb2RlLCBtZXNzYWdlKTtcbiAgICBvbkVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gZmFsbGJhY2sgPz8gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgIGVycm9yLFxuICAgICAga2V5LFxuICAgICAgbmFtZXNwYWNlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlQmFzZUZuKC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzLCBfZmFsbGJhY2spIHtcbiAgICBjb25zdCBmYWxsYmFjayA9IF9mYWxsYmFjaztcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBpZiAoaGFzTWVzc2FnZXNFcnJvcikge1xuICAgICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBmYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uRXJyb3IobWVzc2FnZXNPckVycm9yKTtcbiAgICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgICAgZXJyb3I6IG1lc3NhZ2VzT3JFcnJvcixcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzT3JFcnJvcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2UgPSByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgICBtZXNzYWdlID0gZmFsbGJhY2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UsIGZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgY29kZSwgZXJyb3JNZXNzYWdlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgY29kZSA9IEludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFO1xuICAgICAgICB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYE1lc3NhZ2UgYXQgXFxgJHtqb2luUGF0aChuYW1lc3BhY2UsIGtleSl9XFxgIHJlc29sdmVkIHRvIGFuIGFycmF5LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS90cmFuc2xhdGlvbnMjYXJyYXlzLW9mLW1lc3NhZ2VzYDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZSA9IEludGxFcnJvckNvZGUuSU5TVUZGSUNJRU5UX1BBVEg7XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgTWVzc2FnZSBhdCBcXGAke2pvaW5QYXRoKG5hbWVzcGFjZSwga2V5KX1cXGAgcmVzb2x2ZWQgdG8gYW4gb2JqZWN0LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFVzZSBhIFxcYC5cXGAgdG8gcmV0cmlldmUgbmVzdGVkIG1lc3NhZ2VzLiBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvdHJhbnNsYXRpb25zI3N0cnVjdHVyaW5nLW1lc3NhZ2VzYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgY29kZSwgZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2VGb3JtYXQ7XG5cbiAgICAvLyBIb3QgcGF0aCB0aGF0IGF2b2lkcyBjcmVhdGluZyBhbiBgSW50bE1lc3NhZ2VGb3JtYXRgIGluc3RhbmNlXG4gICAgY29uc3QgcGxhaW5NZXNzYWdlID0gZ2V0UGxhaW5NZXNzYWdlKG1lc3NhZ2UsIHZhbHVlcyk7XG4gICAgaWYgKHBsYWluTWVzc2FnZSkgcmV0dXJuIHBsYWluTWVzc2FnZTtcblxuICAgIC8vIExhenkgaW5pdCB0aGUgbWVzc2FnZSBmb3JtYXR0ZXIgZm9yIGJldHRlciB0cmVlXG4gICAgLy8gc2hha2luZyBpbiBjYXNlIG1lc3NhZ2UgZm9ybWF0dGluZyBpcyBub3QgdXNlZC5cbiAgICBpZiAoIWZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdCkge1xuICAgICAgZm9ybWF0dGVycy5nZXRNZXNzYWdlRm9ybWF0ID0gY3JlYXRlTWVzc2FnZUZvcm1hdHRlcihjYWNoZSwgZm9ybWF0dGVycyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBtZXNzYWdlRm9ybWF0ID0gZm9ybWF0dGVycy5nZXRNZXNzYWdlRm9ybWF0KG1lc3NhZ2UsIGxvY2FsZSwgY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0KGdsb2JhbEZvcm1hdHMsIGZvcm1hdHMsIHRpbWVab25lKSwge1xuICAgICAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgICAgLi4uZm9ybWF0dGVycyxcbiAgICAgICAgICBnZXREYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzQyNzlcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIHtcbiAgICAgICAgICAgICAgdGltZVpvbmUsXG4gICAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHRocm93bkVycm9yID0gZXJyb3I7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRSwgdGhyb3duRXJyb3IubWVzc2FnZSArICgnb3JpZ2luYWxNZXNzYWdlJyBpbiB0aHJvd25FcnJvciA/IGAgKCR7dGhyb3duRXJyb3Iub3JpZ2luYWxNZXNzYWdlfSlgIDogJycpICwgZmFsbGJhY2spO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2VGb3JtYXQuZm9ybWF0KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgaW50bC1tZXNzYWdlZm9ybWF0YCBleHBlY3RzIGEgZGlmZmVyZW50IGZvcm1hdFxuICAgICAgLy8gZm9yIHJpY2ggdGV4dCBlbGVtZW50cyBzaW5jZSBhIHJlY2VudCBtaW5vciB1cGRhdGUuIFRoaXNcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGV2YWx1YXRlZCBpbiBkZXRhaWwsIHBvc3NpYmx5IGFsc28gaW4gcmVnYXJkc1xuICAgICAgLy8gdG8gYmUgYWJsZSB0byBmb3JtYXQgdG8gcGFydHMuXG4gICAgICB2YWx1ZXMgPyBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXModmFsdWVzKSA6IHZhbHVlcyk7XG4gICAgICBpZiAoZm9ybWF0dGVkTWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZvcm1hdCBcXGAke2tleX1cXGAgaW4gJHtuYW1lc3BhY2UgPyBgbmFtZXNwYWNlIFxcYCR7bmFtZXNwYWNlfVxcYGAgOiAnbWVzc2FnZXMnfWAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTGltaXQgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSB0byByZXR1cm4gc3RyaW5ncyBvciBSZWFjdCBlbGVtZW50c1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9pc1ZhbGlkRWxlbWVudChmb3JtYXR0ZWRNZXNzYWdlKSB8fFxuICAgICAgLy8gQXJyYXlzIG9mIFJlYWN0IGVsZW1lbnRzXG4gICAgICBBcnJheS5pc0FycmF5KGZvcm1hdHRlZE1lc3NhZ2UpIHx8IHR5cGVvZiBmb3JtYXR0ZWRNZXNzYWdlID09PSAnc3RyaW5nJyA/IGZvcm1hdHRlZE1lc3NhZ2UgOiBTdHJpbmcoZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSwgZmFsbGJhY2spO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cmFuc2xhdGVGbigvKiogVXNlIGEgZG90IHRvIGluZGljYXRlIGEgbGV2ZWwgb2YgbmVzdGluZyAoZS5nLiBgbmFtZXNwYWNlLm5lc3RlZExhYmVsYCkuICovXG4gIGtleSwgLyoqIEtleSB2YWx1ZSBwYWlycyBmb3IgdmFsdWVzIHRvIGludGVycG9sYXRlIGludG8gdGhlIG1lc3NhZ2UuICovXG4gIHZhbHVlcywgLyoqIEN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMsIF9mYWxsYmFjaykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZUJhc2VGbihrZXksIHZhbHVlcywgZm9ybWF0cywgX2ZhbGxiYWNrKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCBgVGhlIG1lc3NhZ2UgXFxgJHtrZXl9XFxgIGluICR7bmFtZXNwYWNlID8gYG5hbWVzcGFjZSBcXGAke25hbWVzcGFjZX1cXGBgIDogJ21lc3NhZ2VzJ30gZGlkbid0IHJlc29sdmUgdG8gYSBzdHJpbmcuIElmIHlvdSB3YW50IHRvIGZvcm1hdCByaWNoIHRleHQsIHVzZSBcXGB0LnJpY2hcXGAgaW5zdGVhZC5gICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHJhbnNsYXRlRm4ucmljaCA9IHRyYW5zbGF0ZUJhc2VGbjtcblxuICAvLyBBdWdtZW50IGB0cmFuc2xhdGVCYXNlRm5gIHRvIHJldHVybiBwbGFpbiBzdHJpbmdzXG4gIHRyYW5zbGF0ZUZuLm1hcmt1cCA9IChrZXksIHZhbHVlcywgZm9ybWF0cywgX2ZhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGBNYXJrdXBUcmFuc2xhdGlvblZhbHVlc2AgaXMgcHJhY3RpY2FsbHkgYSBzdWIgdHlwZVxuICAgIC8vIG9mIGBSaWNoVHJhbnNsYXRpb25WYWx1ZXNgIGJ1dCBUeXBlU2NyaXB0IGlzbid0IHNtYXJ0IGVub3VnaCBoZXJlLlxuICAgIHZhbHVlcywgZm9ybWF0cywgX2ZhbGxiYWNrKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIFwiYHQubWFya3VwYCBvbmx5IGFjY2VwdHMgZnVuY3Rpb25zIGZvciBmb3JtYXR0aW5nIHRoYXQgcmVjZWl2ZSBhbmQgcmV0dXJuIHN0cmluZ3MuXFxuXFxuRS5nLiB0Lm1hcmt1cCgnbWFya3VwJywge2I6IChjaHVua3MpID0+IGA8Yj4ke2NodW5rc308L2I+YH0pXCIpO1xuICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgdHJhbnNsYXRlRm4ucmF3ID0ga2V5ID0+IHtcbiAgICBpZiAoaGFzTWVzc2FnZXNFcnJvcikge1xuICAgICAgb25FcnJvcihtZXNzYWdlc09yRXJyb3IpO1xuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIHRyYW5zbGF0ZUZuLmhhcyA9IGtleSA9PiB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXNPckVycm9yLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFuc2xhdGVGbjtcbn1cblxuLyoqXG4gKiBGb3IgdGhlIHN0cmljdGx5IHR5cGVkIG1lc3NhZ2VzIHRvIHdvcmsgd2UgaGF2ZSB0byB3cmFwIHRoZSBuYW1lc3BhY2UgaW50b1xuICogYSBtYW5kYXRvcnkgcHJlZml4LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICovXG5mdW5jdGlvbiByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIHJldHVybiBuYW1lc3BhY2UgPT09IG5hbWVzcGFjZVByZWZpeCA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZS5zbGljZSgobmFtZXNwYWNlUHJlZml4ICsgJy4nKS5sZW5ndGgpO1xufVxuXG5jb25zdCBTRUNPTkQgPSAxO1xuY29uc3QgTUlOVVRFID0gU0VDT05EICogNjA7XG5jb25zdCBIT1VSID0gTUlOVVRFICogNjA7XG5jb25zdCBEQVkgPSBIT1VSICogMjQ7XG5jb25zdCBXRUVLID0gREFZICogNztcbmNvbnN0IE1PTlRIID0gREFZICogKDM2NSAvIDEyKTsgLy8gQXBwcm94aW1hdGlvblxuY29uc3QgUVVBUlRFUiA9IE1PTlRIICogMztcbmNvbnN0IFlFQVIgPSBEQVkgKiAzNjU7XG5jb25zdCBVTklUX1NFQ09ORFMgPSB7XG4gIHNlY29uZDogU0VDT05ELFxuICBzZWNvbmRzOiBTRUNPTkQsXG4gIG1pbnV0ZTogTUlOVVRFLFxuICBtaW51dGVzOiBNSU5VVEUsXG4gIGhvdXI6IEhPVVIsXG4gIGhvdXJzOiBIT1VSLFxuICBkYXk6IERBWSxcbiAgZGF5czogREFZLFxuICB3ZWVrOiBXRUVLLFxuICB3ZWVrczogV0VFSyxcbiAgbW9udGg6IE1PTlRILFxuICBtb250aHM6IE1PTlRILFxuICBxdWFydGVyOiBRVUFSVEVSLFxuICBxdWFydGVyczogUVVBUlRFUixcbiAgeWVhcjogWUVBUixcbiAgeWVhcnM6IFlFQVJcbn07XG5mdW5jdGlvbiByZXNvbHZlUmVsYXRpdmVUaW1lVW5pdChzZWNvbmRzKSB7XG4gIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnMoc2Vjb25kcyk7XG4gIGlmIChhYnNWYWx1ZSA8IE1JTlVURSkge1xuICAgIHJldHVybiAnc2Vjb25kJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IEhPVVIpIHtcbiAgICByZXR1cm4gJ21pbnV0ZSc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBEQVkpIHtcbiAgICByZXR1cm4gJ2hvdXInO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgV0VFSykge1xuICAgIHJldHVybiAnZGF5JztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IE1PTlRIKSB7XG4gICAgcmV0dXJuICd3ZWVrJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IFlFQVIpIHtcbiAgICByZXR1cm4gJ21vbnRoJztcbiAgfVxuICByZXR1cm4gJ3llYXInO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCkge1xuICAvLyBXZSBoYXZlIHRvIHJvdW5kIHRoZSByZXN1bHRpbmcgdmFsdWVzLCBhcyBgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXRgXG4gIC8vIHdpbGwgaW5jbHVkZSBmcmFjdGlvbnMgbGlrZSAnMi4xIGhvdXJzIGFnbycuXG4gIHJldHVybiBNYXRoLnJvdW5kKHNlY29uZHMgLyBVTklUX1NFQ09ORFNbdW5pdF0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBfY2FjaGU6IGNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICBfZm9ybWF0dGVyczogZm9ybWF0dGVycyA9IGNyZWF0ZUludGxGb3JtYXR0ZXJzKGNhY2hlKSxcbiAgICBmb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICBvbkVycm9yID0gZGVmYXVsdE9uRXJyb3IsXG4gICAgdGltZVpvbmU6IGdsb2JhbFRpbWVab25lXG4gIH0gPSBwcm9wcztcbiAgZnVuY3Rpb24gYXBwbHlUaW1lWm9uZShvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zPy50aW1lWm9uZSkge1xuICAgICAgaWYgKGdsb2JhbFRpbWVab25lKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBgVGhlIFxcYHRpbWVab25lXFxgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0IHRvIGF2b2lkIG1hcmt1cCBtaXNtYXRjaGVzIGNhdXNlZCBieSBlbnZpcm9ubWVudCBkaWZmZXJlbmNlcy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlRm9ybWF0T3JPcHRpb25zKHR5cGVGb3JtYXRzLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgZm9ybWF0T3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZm9ybWF0TmFtZSA9IGZvcm1hdE9yT3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB0eXBlRm9ybWF0cz8uW2Zvcm1hdE5hbWVdO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLk1JU1NJTkdfRk9STUFULCBgRm9ybWF0IFxcYCR7Zm9ybWF0TmFtZX1cXGAgaXMgbm90IGF2YWlsYWJsZS5gICk7XG4gICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZvcm1hdE9yT3B0aW9ucztcbiAgICB9XG4gICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ub3ZlcnJpZGVzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgdHlwZUZvcm1hdHMsIGZvcm1hdHRlciwgZ2V0RmFsbGJhY2spIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjaygpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRhdGVUaW1lKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8uZGF0ZVRpbWUsIG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucyA9IGFwcGx5VGltZVpvbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWVSYW5nZShzdGFydCwgZW5kLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8uZGF0ZVRpbWUsIG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucyA9IGFwcGx5VGltZVpvbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH0sICgpID0+IFtkYXRlVGltZShzdGFydCksIGRhdGVUaW1lKGVuZCldLmpvaW4oJ+KAieKAk+KAiScpKTtcbiAgfVxuICBmdW5jdGlvbiBudW1iZXIodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5udW1iZXIsIG9wdGlvbnMgPT4gZm9ybWF0dGVycy5nZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpLCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRHbG9iYWxOb3coKSB7XG4gICAgLy8gT25seSByZWFkIHdoZW4gbmVjZXNzYXJ5IHRvIGF2b2lkIHRyaWdnZXJpbmcgYSBgZHluYW1pY0lPYCBlcnJvclxuICAgIC8vIHVubmVjZXNzYXJpbHkgKGBub3dgIGlzIG9ubHkgbmVlZGVkIGZvciBgZm9ybWF0LnJlbGF0aXZlVGltZWApXG4gICAgaWYgKHByb3BzLm5vdykge1xuICAgICAgcmV0dXJuIHByb3BzLm5vdztcbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIGBUaGUgXFxgbm93XFxgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgdG8gXFxgcmVsYXRpdmVUaW1lXFxgIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLCB0aGVyZWZvcmUgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWQgYXMgYSBmYWxsYmFjay4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL2RhdGVzLXRpbWVzI3JlbGF0aXZlLXRpbWVzLXVzZW5vd2AgKSk7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKGRhdGUsIG5vd09yT3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBsZXQgbm93RGF0ZSwgdW5pdDtcbiAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgIGlmIChub3dPck9wdGlvbnMgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBub3dPck9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vd0RhdGUgPSBuZXcgRGF0ZShub3dPck9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChub3dPck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG5vd09yT3B0aW9ucy5ub3cgIT0gbnVsbCkge1xuICAgICAgICAgIG5vd0RhdGUgPSBuZXcgRGF0ZShub3dPck9wdGlvbnMubm93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3dEYXRlID0gZ2V0R2xvYmFsTm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdCA9IG5vd09yT3B0aW9ucy51bml0O1xuICAgICAgICBvcHRzLnN0eWxlID0gbm93T3JPcHRpb25zLnN0eWxlO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFR5cGVzIGFyZSBzbGlnaHRseSBvdXRkYXRlZFxuICAgICAgICBvcHRzLm51bWJlcmluZ1N5c3RlbSA9IG5vd09yT3B0aW9ucy5udW1iZXJpbmdTeXN0ZW07XG4gICAgICB9XG4gICAgICBpZiAoIW5vd0RhdGUpIHtcbiAgICAgICAgbm93RGF0ZSA9IGdldEdsb2JhbE5vdygpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0ZURhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIGNvbnN0IHNlY29uZHMgPSAoZGF0ZURhdGUuZ2V0VGltZSgpIC0gbm93RGF0ZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICAgIGlmICghdW5pdCkge1xuICAgICAgICB1bml0ID0gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGBudW1lcmljOiAnYXV0bydgIGNhbiB0aGVvcmV0aWNhbGx5IHByb2R1Y2Ugb3V0cHV0IGxpa2UgXCJ5ZXN0ZXJkYXlcIixcbiAgICAgIC8vIGJ1dCBpdCBvbmx5IHdvcmtzIHdpdGggaW50ZWdlcnMuIEUuZy4gLTEgZGF5IHdpbGwgcHJvZHVjZSBcInllc3RlcmRheVwiLFxuICAgICAgLy8gYnV0IC0xLjEgZGF5cyB3aWxsIHByb2R1Y2UgXCItMS4xIGRheXNcIi4gUm91bmRpbmcgYmVmb3JlIGZvcm1hdHRpbmcgaXNcbiAgICAgIC8vIG5vdCBkZXNpcmVkLCBhcyB0aGUgZ2l2ZW4gZGF0ZXMgbWlnaHQgY3Jvc3MgYSB0aHJlc2hvbGQgd2VyZSB0aGVcbiAgICAgIC8vIG91dHB1dCBpc24ndCBjb3JyZWN0IGFueW1vcmUuIEV4YW1wbGU6IDIwMjQtMDEtMDhUMjM6MDA6MDAuMDAwWiBhbmRcbiAgICAgIC8vIDIwMjQtMDEtMDhUMDE6MDA6MDAuMDAwWiB3b3VsZCBwcm9kdWNlIFwieWVzdGVyZGF5XCIsIHdoaWNoIGlzIG5vdCB0aGVcbiAgICAgIC8vIGNhc2UuIEJ5IHVzaW5nIGBhbHdheXNgIHdlIGNhbiBlbnN1cmUgY29ycmVjdCBvdXRwdXQuIFRoZSBvbmx5IGV4Y2VwdGlvblxuICAgICAgLy8gaXMgdGhlIGZvcm1hdHRpbmcgb2YgdGltZXMgPDEgc2Vjb25kIGFzIFwibm93XCIuXG4gICAgICBvcHRzLm51bWVyaWMgPSB1bml0ID09PSAnc2Vjb25kJyA/ICdhdXRvJyA6ICdhbHdheXMnO1xuICAgICAgY29uc3QgdmFsdWUgPSBjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZShzZWNvbmRzLCB1bml0KTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldFJlbGF0aXZlVGltZUZvcm1hdChsb2NhbGUsIG9wdHMpLmZvcm1hdCh2YWx1ZSwgdW5pdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxpc3QodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0gW107XG4gICAgY29uc3QgcmljaFZhbHVlcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGBmb3JtYXRUb1BhcnRzYCBvbmx5IGFjY2VwdHMgc3RyaW5ncywgdGhlcmVmb3JlIHdlIGhhdmUgdG8gdGVtcG9yYXJpbHlcbiAgICAvLyByZXBsYWNlIFJlYWN0IGVsZW1lbnRzIHdpdGggYSBwbGFjZWhvbGRlciBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlXG4gICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlIGFmdGVyd2FyZHMuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIGxldCBzZXJpYWxpemVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2VyaWFsaXplZEl0ZW0gPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICByaWNoVmFsdWVzLnNldChzZXJpYWxpemVkSXRlbSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpdGVtKTtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6ZWRWYWx1ZS5wdXNoKHNlcmlhbGl6ZWRJdGVtKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8ubGlzdCxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGByaWNoVmFsdWVzLnNpemVgIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZXR1cm4gdHlwZSwgYnV0IFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdGhlIG1lYW5pbmcgb2YgdGhpcyBjb3JyZWN0bHlcbiAgICBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdHRlcnMuZ2V0TGlzdEZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFRvUGFydHMoc2VyaWFsaXplZFZhbHVlKS5tYXAocGFydCA9PiBwYXJ0LnR5cGUgPT09ICdsaXRlcmFsJyA/IHBhcnQudmFsdWUgOiByaWNoVmFsdWVzLmdldChwYXJ0LnZhbHVlKSB8fCBwYXJ0LnZhbHVlKTtcbiAgICAgIGlmIChyaWNoVmFsdWVzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0sICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0ZVRpbWUsXG4gICAgbnVtYmVyLFxuICAgIHJlbGF0aXZlVGltZSxcbiAgICBsaXN0LFxuICAgIGRhdGVUaW1lUmFuZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIHBhcmVudFBhdGgpIHtcbiAgT2JqZWN0LmVudHJpZXMobWVzc2FnZXMpLmZvckVhY2goKFtrZXksIG1lc3NhZ2VPck1lc3NhZ2VzXSkgPT4ge1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgbGV0IGtleUxhYmVsID0ga2V5O1xuICAgICAgaWYgKHBhcmVudFBhdGgpIGtleUxhYmVsICs9IGAgKGF0ICR7cGFyZW50UGF0aH0pYDtcbiAgICAgIGludmFsaWRLZXlMYWJlbHMucHVzaChrZXlMYWJlbCk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAobWVzc2FnZU9yTWVzc2FnZXMgIT0gbnVsbCAmJiB0eXBlb2YgbWVzc2FnZU9yTWVzc2FnZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlT3JNZXNzYWdlcywgaW52YWxpZEtleUxhYmVscywgam9pblBhdGgocGFyZW50UGF0aCwga2V5KSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMsIG9uRXJyb3IpIHtcbiAgY29uc3QgaW52YWxpZEtleUxhYmVscyA9IFtdO1xuICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlcywgaW52YWxpZEtleUxhYmVscyk7XG4gIGlmIChpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5JTlZBTElEX0tFWSwgYE5hbWVzcGFjZSBrZXlzIGNhbiBub3QgY29udGFpbiB0aGUgY2hhcmFjdGVyIFwiLlwiIGFzIHRoaXMgaXMgdXNlZCB0byBleHByZXNzIG5lc3RpbmcuIFBsZWFzZSByZW1vdmUgaXQgb3IgcmVwbGFjZSBpdCB3aXRoIGFub3RoZXIgY2hhcmFjdGVyLlxuXG5JbnZhbGlkICR7aW52YWxpZEtleUxhYmVscy5sZW5ndGggPT09IDEgPyAna2V5JyA6ICdrZXlzJ306ICR7aW52YWxpZEtleUxhYmVscy5qb2luKCcsICcpfVxuXG5JZiB5b3UncmUgbWlncmF0aW5nIGZyb20gYSBmbGF0IHN0cnVjdHVyZSwgeW91IGNhbiBjb252ZXJ0IHlvdXIgbWVzc2FnZXMgYXMgZm9sbG93czpcblxuaW1wb3J0IHtzZXR9IGZyb20gXCJsb2Rhc2hcIjtcblxuY29uc3QgaW5wdXQgPSB7XG4gIFwib25lLm9uZVwiOiBcIjEuMVwiLFxuICBcIm9uZS50d29cIjogXCIxLjJcIixcbiAgXCJ0d28ub25lLm9uZVwiOiBcIjIuMS4xXCJcbn07XG5cbmNvbnN0IG91dHB1dCA9IE9iamVjdC5lbnRyaWVzKGlucHV0KS5yZWR1Y2UoXG4gIChhY2MsIFtrZXksIHZhbHVlXSkgPT4gc2V0KGFjYywga2V5LCB2YWx1ZSksXG4gIHt9XG4pO1xuXG4vLyBPdXRwdXQ6XG4vL1xuLy8ge1xuLy8gICBcIm9uZVwiOiB7XG4vLyAgICAgXCJvbmVcIjogXCIxLjFcIixcbi8vICAgICBcInR3b1wiOiBcIjEuMlwiXG4vLyAgIH0sXG4vLyAgIFwidHdvXCI6IHtcbi8vICAgICBcIm9uZVwiOiB7XG4vLyAgICAgICBcIm9uZVwiOiBcIjIuMS4xXCJcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cbmAgKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmhhbmNlcyB0aGUgaW5jb21pbmcgcHJvcHMgd2l0aCBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbmZpZyh7XG4gIGZvcm1hdHMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgbWVzc2FnZXMsXG4gIG9uRXJyb3IsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgZmluYWxPbkVycm9yID0gb25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcbiAgY29uc3QgZmluYWxHZXRNZXNzYWdlRmFsbGJhY2sgPSBnZXRNZXNzYWdlRmFsbGJhY2sgfHwgZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjaztcbiAge1xuICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgZmluYWxPbkVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIGZvcm1hdHM6IGZvcm1hdHMgfHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCB1bmRlZmluZWQsXG4gICAgb25FcnJvcjogZmluYWxPbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjazogZmluYWxHZXRNZXNzYWdlRmFsbGJhY2tcbiAgfTtcbn1cblxuZXhwb3J0IHsgSW50bEVycm9yIGFzIEksIEludGxFcnJvckNvZGUgYXMgYSwgY3JlYXRlSW50bEZvcm1hdHRlcnMgYXMgYiwgY3JlYXRlRm9ybWF0dGVyIGFzIGMsIGNyZWF0ZUNhY2hlIGFzIGQsIGNyZWF0ZUJhc2VUcmFuc2xhdG9yIGFzIGUsIGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2sgYXMgZiwgZGVmYXVsdE9uRXJyb3IgYXMgZywgaW5pdGlhbGl6ZUNvbmZpZyBhcyBpLCByZXNvbHZlTmFtZXNwYWNlIGFzIHIgfTtcbiJdLCJuYW1lcyI6WyJJbnRsTWVzc2FnZUZvcm1hdCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwibWVtb2l6ZSIsInN0cmF0ZWdpZXMiLCJJbnRsRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY29kZSIsIm9yaWdpbmFsTWVzc2FnZSIsIm1lc3NhZ2UiLCJJbnRsRXJyb3JDb2RlIiwiY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0IiwiZ2xvYmFsRm9ybWF0cyIsImlubGluZUZvcm1hdHMiLCJ0aW1lWm9uZSIsIm1mRGF0ZURlZmF1bHRzIiwiZm9ybWF0cyIsImRhdGUiLCJtZlRpbWVEZWZhdWx0cyIsInRpbWUiLCJkYXRlVGltZUZvcm1hdHMiLCJkYXRlVGltZSIsImFsbEZvcm1hdHMiLCJudW1iZXIiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJqb2luUGF0aCIsInBhcnRzIiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwicHJvcHMiLCJuYW1lc3BhY2UiLCJkZWZhdWx0T25FcnJvciIsImVycm9yIiwiY29uc29sZSIsImNyZWF0ZUNhY2hlIiwicmVsYXRpdmVUaW1lIiwicGx1cmFsUnVsZXMiLCJsaXN0IiwiZGlzcGxheU5hbWVzIiwiY3JlYXRlTWVtb0NhY2hlIiwic3RvcmUiLCJjcmVhdGUiLCJnZXQiLCJzZXQiLCJtZW1vRm4iLCJmbiIsImNhY2hlIiwic3RyYXRlZ3kiLCJ2YXJpYWRpYyIsIm1lbW9Db25zdHJ1Y3RvciIsIkNvbnN0cnVjdG9yRm4iLCJhcmdzIiwiY3JlYXRlSW50bEZvcm1hdHRlcnMiLCJnZXREYXRlVGltZUZvcm1hdCIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsImdldE51bWJlckZvcm1hdCIsIk51bWJlckZvcm1hdCIsImdldFBsdXJhbFJ1bGVzIiwiUGx1cmFsUnVsZXMiLCJnZXRSZWxhdGl2ZVRpbWVGb3JtYXQiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiLCJnZXRMaXN0Rm9ybWF0IiwiTGlzdEZvcm1hdCIsImdldERpc3BsYXlOYW1lcyIsIkRpc3BsYXlOYW1lcyIsImNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIiLCJpbnRsRm9ybWF0dGVycyIsImdldE1lc3NhZ2VGb3JtYXQiLCJmb3JtYXR0ZXJzIiwicmVzb2x2ZVBhdGgiLCJsb2NhbGUiLCJtZXNzYWdlcyIsImZ1bGxLZXkiLCJzcGxpdCIsInBhcnQiLCJuZXh0IiwicHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzIiwidmFsdWVzIiwidHJhbnNmb3JtZWRWYWx1ZXMiLCJrZXlzIiwiaW5kZXgiLCJ0cmFuc2Zvcm1lZCIsImNodW5rcyIsInJlc3VsdCIsImdldE1lc3NhZ2VzT3JFcnJvciIsInJldHJpZXZlZE1lc3NhZ2VzIiwiaW50bEVycm9yIiwiTUlTU0lOR19NRVNTQUdFIiwiZ2V0UGxhaW5NZXNzYWdlIiwiY2FuZGlkYXRlIiwidGVzdCIsInVuZGVmaW5lZCIsImNyZWF0ZUJhc2VUcmFuc2xhdG9yIiwiY29uZmlnIiwibWVzc2FnZXNPckVycm9yIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwib25FcnJvciIsImhhc01lc3NhZ2VzRXJyb3IiLCJnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeSIsImZhbGxiYWNrIiwidHJhbnNsYXRlQmFzZUZuIiwiX2ZhbGxiYWNrIiwiZXJyb3JNZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiSU5WQUxJRF9NRVNTQUdFIiwiSU5TVUZGSUNJRU5UX1BBVEgiLCJtZXNzYWdlRm9ybWF0IiwicGxhaW5NZXNzYWdlIiwibG9jYWxlcyIsIm9wdGlvbnMiLCJ0aHJvd25FcnJvciIsImZvcm1hdHRlZE1lc3NhZ2UiLCJmb3JtYXQiLCJTdHJpbmciLCJGT1JNQVRUSU5HX0VSUk9SIiwidHJhbnNsYXRlRm4iLCJyaWNoIiwibWFya3VwIiwicmF3IiwiaGFzIiwicmVzb2x2ZU5hbWVzcGFjZSIsIm5hbWVzcGFjZVByZWZpeCIsInNsaWNlIiwibGVuZ3RoIiwiU0VDT05EIiwiTUlOVVRFIiwiSE9VUiIsIkRBWSIsIldFRUsiLCJNT05USCIsIlFVQVJURVIiLCJZRUFSIiwiVU5JVF9TRUNPTkRTIiwic2Vjb25kIiwic2Vjb25kcyIsIm1pbnV0ZSIsIm1pbnV0ZXMiLCJob3VyIiwiaG91cnMiLCJkYXkiLCJkYXlzIiwid2VlayIsIndlZWtzIiwibW9udGgiLCJtb250aHMiLCJxdWFydGVyIiwicXVhcnRlcnMiLCJ5ZWFyIiwieWVhcnMiLCJyZXNvbHZlUmVsYXRpdmVUaW1lVW5pdCIsImFic1ZhbHVlIiwiTWF0aCIsImFicyIsImNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlIiwidW5pdCIsInJvdW5kIiwiY3JlYXRlRm9ybWF0dGVyIiwiX2NhY2hlIiwiX2Zvcm1hdHRlcnMiLCJnbG9iYWxUaW1lWm9uZSIsImFwcGx5VGltZVpvbmUiLCJFTlZJUk9OTUVOVF9GQUxMQkFDSyIsInJlc29sdmVGb3JtYXRPck9wdGlvbnMiLCJ0eXBlRm9ybWF0cyIsImZvcm1hdE9yT3B0aW9ucyIsIm92ZXJyaWRlcyIsImZvcm1hdE5hbWUiLCJNSVNTSU5HX0ZPUk1BVCIsImdldEZvcm1hdHRlZFZhbHVlIiwiZm9ybWF0dGVyIiwiZ2V0RmFsbGJhY2siLCJkYXRlVGltZVJhbmdlIiwic3RhcnQiLCJlbmQiLCJmb3JtYXRSYW5nZSIsImdldEdsb2JhbE5vdyIsIm5vdyIsIkRhdGUiLCJub3dPck9wdGlvbnMiLCJub3dEYXRlIiwib3B0cyIsInN0eWxlIiwibnVtYmVyaW5nU3lzdGVtIiwiZGF0ZURhdGUiLCJnZXRUaW1lIiwibnVtZXJpYyIsInNlcmlhbGl6ZWRWYWx1ZSIsInJpY2hWYWx1ZXMiLCJNYXAiLCJpdGVtIiwic2VyaWFsaXplZEl0ZW0iLCJwdXNoIiwiZm9ybWF0VG9QYXJ0cyIsIm1hcCIsInR5cGUiLCJzaXplIiwidmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQiLCJpbnZhbGlkS2V5TGFiZWxzIiwicGFyZW50UGF0aCIsIm1lc3NhZ2VPck1lc3NhZ2VzIiwiaW5jbHVkZXMiLCJrZXlMYWJlbCIsInZhbGlkYXRlTWVzc2FnZXMiLCJJTlZBTElEX0tFWSIsImluaXRpYWxpemVDb25maWciLCJyZXN0IiwiZmluYWxPbkVycm9yIiwiZmluYWxHZXRNZXNzYWdlRmFsbGJhY2siLCJJIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImkiLCJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/esm/development/react.js":
/*!*************************************************************!*\
  !*** ./node_modules/use-intl/dist/esm/development/react.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntlProvider: () => (/* binding */ IntlProvider),\n/* harmony export */   _useExtracted: () => (/* binding */ useExtracted),\n/* harmony export */   useFormatter: () => (/* binding */ useFormatter),\n/* harmony export */   useLocale: () => (/* binding */ useLocale),\n/* harmony export */   useMessages: () => (/* binding */ useMessages),\n/* harmony export */   useNow: () => (/* binding */ useNow),\n/* harmony export */   useTimeZone: () => (/* binding */ useTimeZone),\n/* harmony export */   useTranslations: () => (/* binding */ useTranslations)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initializeConfig-CIDVMS2E.js */ \"(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n\n\n\nconst IntlContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nfunction IntlProvider({ children, formats, getMessageFallback, locale, messages, now, onError, timeZone }) {\n    const prevContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IntlContext);\n    // The formatter cache is released when the locale changes. For\n    // long-running apps with a persistent `IntlProvider` at the root,\n    // this can reduce the memory footprint (e.g. in React Native).\n    const cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return prevContext?.cache || (0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.d)();\n    }, [\n        locale,\n        prevContext?.cache\n    ]);\n    const formatters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>prevContext?.formatters || (0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.b)(cache), [\n        cache,\n        prevContext?.formatters\n    ]);\n    // Memoizing this value helps to avoid triggering a re-render of all\n    // context consumers in case the configuration didn't change. However,\n    // if some of the non-primitive values change, a re-render will still\n    // be triggered. Note that there's no need to put `memo` on `IntlProvider`\n    // itself, because the `children` typically change on every render.\n    // There's some burden on the consumer side if it's important to reduce\n    // re-renders, put that's how React works.\n    // See: https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#context-updates-and-render-optimizations\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            ...(0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.i)({\n                locale,\n                // (required by provider)\n                formats: formats === undefined ? prevContext?.formats : formats,\n                getMessageFallback: getMessageFallback || prevContext?.getMessageFallback,\n                messages: messages === undefined ? prevContext?.messages : messages,\n                now: now || prevContext?.now,\n                onError: onError || prevContext?.onError,\n                timeZone: timeZone || prevContext?.timeZone\n            }),\n            formatters,\n            cache\n        }), [\n        cache,\n        formats,\n        formatters,\n        getMessageFallback,\n        locale,\n        messages,\n        now,\n        onError,\n        prevContext,\n        timeZone\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IntlContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useIntlContext() {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IntlContext);\n    if (!context) {\n        throw new Error(\"No intl context found. Have you configured the provider? See https://next-intl.dev/docs/usage/configuration#server-client-components\");\n    }\n    return context;\n}\nlet hasWarnedForMissingTimezone = false;\nconst isServer = \"undefined\" === \"undefined\";\nfunction useTranslationsImpl(allMessagesPrefixed, namespacePrefixed, namespacePrefix) {\n    const { cache, formats: globalFormats, formatters, getMessageFallback, locale, onError, timeZone } = useIntlContext();\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the hook invocation.\n    const allMessages = allMessagesPrefixed[namespacePrefix];\n    const namespace = (0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.r)(namespacePrefixed, namespacePrefix);\n    if (!timeZone && !hasWarnedForMissingTimezone && isServer) {\n        // eslint-disable-next-line react-compiler/react-compiler\n        hasWarnedForMissingTimezone = true;\n        onError(new _initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.I(_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.a.ENVIRONMENT_FALLBACK, `There is no \\`timeZone\\` configured, this can lead to markup mismatches caused by environment differences. Consider adding a global default: https://next-intl.dev/docs/configuration#time-zone`));\n    }\n    const translate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.e)({\n            cache,\n            formatters,\n            getMessageFallback,\n            messages: allMessages,\n            namespace,\n            onError,\n            formats: globalFormats,\n            locale,\n            timeZone\n        }), [\n        cache,\n        formatters,\n        getMessageFallback,\n        allMessages,\n        namespace,\n        onError,\n        globalFormats,\n        locale,\n        timeZone\n    ]);\n    return translate;\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function useTranslations(namespace) {\n    const context = useIntlContext();\n    const messages = context.messages;\n    // We have to wrap the actual hook so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    // @ts-expect-error Use the explicit annotation instead\n    return useTranslationsImpl({\n        \"!\": messages\n    }, // @ts-expect-error\n    namespace ? `!.${namespace}` : \"!\", \"!\");\n}\nfunction useLocale() {\n    return useIntlContext().locale;\n}\nfunction getNow() {\n    return new Date();\n}\n/**\n * @see https://next-intl.dev/docs/usage/dates-times#relative-times-usenow\n */ function useNow(options) {\n    const updateInterval = options?.updateInterval;\n    const { now: globalNow } = useIntlContext();\n    const [now, setNow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalNow || getNow());\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!updateInterval) return;\n        const intervalId = setInterval(()=>{\n            setNow(getNow());\n        }, updateInterval);\n        return ()=>{\n            clearInterval(intervalId);\n        };\n    }, [\n        globalNow,\n        updateInterval\n    ]);\n    return updateInterval == null && globalNow ? globalNow : now;\n}\nfunction useTimeZone() {\n    return useIntlContext().timeZone;\n}\nfunction useMessages() {\n    const context = useIntlContext();\n    if (!context.messages) {\n        throw new Error(\"No messages found. Have you configured them correctly? See https://next-intl.dev/docs/configuration#messages\");\n    }\n    return context.messages;\n}\nfunction useFormatter() {\n    const { formats, formatters, locale, now: globalNow, onError, timeZone } = useIntlContext();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.c)({\n            formats,\n            locale,\n            now: globalNow,\n            onError,\n            timeZone,\n            _formatters: formatters\n        }), [\n        formats,\n        formatters,\n        globalNow,\n        locale,\n        onError,\n        timeZone\n    ]);\n}\nfunction getArgs(messageOrParams, ...rest) {\n    let message, values, formats;\n    if (typeof messageOrParams === \"string\") {\n        message = messageOrParams;\n        values = rest[0];\n        formats = rest[1];\n    } else {\n        message = messageOrParams.message;\n        values = messageOrParams.values;\n        formats = messageOrParams.formats;\n    // `description` is is not used at runtime\n    }\n    // @ts-expect-error -- Secret fallback parameter\n    return [\n        undefined,\n        // Always use fallback if not compiled\n        values,\n        formats,\n        message\n    ];\n}\n// Note: This API is usually compiled into `useTranslations`,\n// but there is some fallback handling which allows this hook\n// to still work when not being compiled.\n//\n// This is relevant for:\n// - Isolated environments like tests, Storybook, etc.\n// - Fallbacks in case an extracted message is not yet available\nfunction useExtracted(namespace) {\n    const t = useTranslations(namespace);\n    function translateFn(...params) {\n        // @ts-expect-error -- Passing `undefined` as an ID is secretly allowed here\n        return t(...getArgs(...params));\n    }\n    translateFn.rich = (...params)=>// @ts-expect-error -- Passing `undefined` as an ID is secretly allowed here\n        t.rich(...getArgs(...params));\n    translateFn.markup = (...params)=>// @ts-expect-error -- Passing `undefined` as an ID is secretly allowed here\n        t.markup(...getArgs(...params));\n    translateFn.has = function translateHasFn(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    message) {\n        // Not really something better we can do here\n        return true;\n    };\n    return translateFn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvcmVhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Y7QUFDZ0o7QUFDeEw7QUFJeEMsTUFBTXNCLGNBQWMsV0FBVyxHQUFFdEIsb0RBQWFBLENBQUN1QjtBQUUvQyxTQUFTQyxhQUFhLEVBQ3BCQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUEMsa0JBQWtCLEVBQ2xCQyxNQUFNLEVBQ05DLFFBQVEsRUFDUkMsR0FBRyxFQUNIQyxPQUFPLEVBQ1BDLFFBQVEsRUFDVDtJQUNDLE1BQU1DLGNBQWNoQyxpREFBVUEsQ0FBQ3FCO0lBRS9CLCtEQUErRDtJQUMvRCxrRUFBa0U7SUFDbEUsK0RBQStEO0lBQy9ELE1BQU1ZLFFBQVFoQyw4Q0FBT0EsQ0FBQztRQUNwQixPQUFPK0IsYUFBYUMsU0FBUzVCLGdFQUFXQTtJQUMxQyxHQUFHO1FBQUNzQjtRQUFRSyxhQUFhQztLQUFNO0lBQy9CLE1BQU1DLGFBQWFqQyw4Q0FBT0EsQ0FBQyxJQUFNK0IsYUFBYUUsY0FBYzNCLGdFQUFvQkEsQ0FBQzBCLFFBQVE7UUFBQ0E7UUFBT0QsYUFBYUU7S0FBVztJQUV6SCxvRUFBb0U7SUFDcEUsc0VBQXNFO0lBQ3RFLHFFQUFxRTtJQUNyRSwwRUFBMEU7SUFDMUUsbUVBQW1FO0lBQ25FLHVFQUF1RTtJQUN2RSwwQ0FBMEM7SUFDMUMsK0pBQStKO0lBQy9KLE1BQU1DLFFBQVFsQyw4Q0FBT0EsQ0FBQyxJQUFPO1lBQzNCLEdBQUdRLGdFQUFnQkEsQ0FBQztnQkFDbEJrQjtnQkFDQSx5QkFBeUI7Z0JBQ3pCRixTQUFTQSxZQUFZSCxZQUFZVSxhQUFhUCxVQUFVQTtnQkFDeERDLG9CQUFvQkEsc0JBQXNCTSxhQUFhTjtnQkFDdkRFLFVBQVVBLGFBQWFOLFlBQVlVLGFBQWFKLFdBQVdBO2dCQUMzREMsS0FBS0EsT0FBT0csYUFBYUg7Z0JBQ3pCQyxTQUFTQSxXQUFXRSxhQUFhRjtnQkFDakND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V0FBV1E7SUFDckJELFlBQVlHLE1BQU0sR0FBRyxDQUFDLEdBQUdGLFNBQ3pCLDRFQUE0RTtRQUM1RUYsRUFBRUksTUFBTSxJQUFJVixXQUFXUTtJQUN2QkQsWUFBWUksR0FBRyxHQUFHLFNBQVNDLGVBQzNCLDZEQUE2RDtJQUM3RFQsT0FBTztRQUNMLDZDQUE2QztRQUM3QyxPQUFPO0lBQ1Q7SUFDQSxPQUFPSTtBQUNUO0FBRW1JIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktYXBwb2ludG1lbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvcmVhY3QuanM/ZjZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZCBhcyBjcmVhdGVDYWNoZSwgYiBhcyBjcmVhdGVJbnRsRm9ybWF0dGVycywgaSBhcyBpbml0aWFsaXplQ29uZmlnLCByIGFzIHJlc29sdmVOYW1lc3BhY2UsIEkgYXMgSW50bEVycm9yLCBhIGFzIEludGxFcnJvckNvZGUsIGUgYXMgY3JlYXRlQmFzZVRyYW5zbGF0b3IsIGMgYXMgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi9pbml0aWFsaXplQ29uZmlnLUNJRFZNUzJFLmpzJztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuXG5cbmNvbnN0IEludGxDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcblxuZnVuY3Rpb24gSW50bFByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIGZvcm1hdHMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgbG9jYWxlLFxuICBtZXNzYWdlcyxcbiAgbm93LFxuICBvbkVycm9yLFxuICB0aW1lWm9uZVxufSkge1xuICBjb25zdCBwcmV2Q29udGV4dCA9IHVzZUNvbnRleHQoSW50bENvbnRleHQpO1xuXG4gIC8vIFRoZSBmb3JtYXR0ZXIgY2FjaGUgaXMgcmVsZWFzZWQgd2hlbiB0aGUgbG9jYWxlIGNoYW5nZXMuIEZvclxuICAvLyBsb25nLXJ1bm5pbmcgYXBwcyB3aXRoIGEgcGVyc2lzdGVudCBgSW50bFByb3ZpZGVyYCBhdCB0aGUgcm9vdCxcbiAgLy8gdGhpcyBjYW4gcmVkdWNlIHRoZSBtZW1vcnkgZm9vdHByaW50IChlLmcuIGluIFJlYWN0IE5hdGl2ZSkuXG4gIGNvbnN0IGNhY2hlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHByZXZDb250ZXh0Py5jYWNoZSB8fCBjcmVhdGVDYWNoZSgpO1xuICB9LCBbbG9jYWxlLCBwcmV2Q29udGV4dD8uY2FjaGVdKTtcbiAgY29uc3QgZm9ybWF0dGVycyA9IHVzZU1lbW8oKCkgPT4gcHJldkNvbnRleHQ/LmZvcm1hdHRlcnMgfHwgY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpLCBbY2FjaGUsIHByZXZDb250ZXh0Py5mb3JtYXR0ZXJzXSk7XG5cbiAgLy8gTWVtb2l6aW5nIHRoaXMgdmFsdWUgaGVscHMgdG8gYXZvaWQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlciBvZiBhbGxcbiAgLy8gY29udGV4dCBjb25zdW1lcnMgaW4gY2FzZSB0aGUgY29uZmlndXJhdGlvbiBkaWRuJ3QgY2hhbmdlLiBIb3dldmVyLFxuICAvLyBpZiBzb21lIG9mIHRoZSBub24tcHJpbWl0aXZlIHZhbHVlcyBjaGFuZ2UsIGEgcmUtcmVuZGVyIHdpbGwgc3RpbGxcbiAgLy8gYmUgdHJpZ2dlcmVkLiBOb3RlIHRoYXQgdGhlcmUncyBubyBuZWVkIHRvIHB1dCBgbWVtb2Agb24gYEludGxQcm92aWRlcmBcbiAgLy8gaXRzZWxmLCBiZWNhdXNlIHRoZSBgY2hpbGRyZW5gIHR5cGljYWxseSBjaGFuZ2Ugb24gZXZlcnkgcmVuZGVyLlxuICAvLyBUaGVyZSdzIHNvbWUgYnVyZGVuIG9uIHRoZSBjb25zdW1lciBzaWRlIGlmIGl0J3MgaW1wb3J0YW50IHRvIHJlZHVjZVxuICAvLyByZS1yZW5kZXJzLCBwdXQgdGhhdCdzIGhvdyBSZWFjdCB3b3Jrcy5cbiAgLy8gU2VlOiBodHRwczovL2Jsb2cuaXNxdWFyZWRzb2Z0d2FyZS5jb20vMjAyMC8wNS9ibG9nZ2VkLWFuc3dlcnMtYS1tb3N0bHktY29tcGxldGUtZ3VpZGUtdG8tcmVhY3QtcmVuZGVyaW5nLWJlaGF2aW9yLyNjb250ZXh0LXVwZGF0ZXMtYW5kLXJlbmRlci1vcHRpbWl6YXRpb25zXG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmluaXRpYWxpemVDb25maWcoe1xuICAgICAgbG9jYWxlLFxuICAgICAgLy8gKHJlcXVpcmVkIGJ5IHByb3ZpZGVyKVxuICAgICAgZm9ybWF0czogZm9ybWF0cyA9PT0gdW5kZWZpbmVkID8gcHJldkNvbnRleHQ/LmZvcm1hdHMgOiBmb3JtYXRzLFxuICAgICAgZ2V0TWVzc2FnZUZhbGxiYWNrOiBnZXRNZXNzYWdlRmFsbGJhY2sgfHwgcHJldkNvbnRleHQ/LmdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyA9PT0gdW5kZWZpbmVkID8gcHJldkNvbnRleHQ/Lm1lc3NhZ2VzIDogbWVzc2FnZXMsXG4gICAgICBub3c6IG5vdyB8fCBwcmV2Q29udGV4dD8ubm93LFxuICAgICAgb25FcnJvcjogb25FcnJvciB8fCBwcmV2Q29udGV4dD8ub25FcnJvcixcbiAgICAgIHRpbWVab25lOiB0aW1lWm9uZSB8fCBwcmV2Q29udGV4dD8udGltZVpvbmVcbiAgICB9KSxcbiAgICBmb3JtYXR0ZXJzLFxuICAgIGNhY2hlXG4gIH0pLCBbY2FjaGUsIGZvcm1hdHMsIGZvcm1hdHRlcnMsIGdldE1lc3NhZ2VGYWxsYmFjaywgbG9jYWxlLCBtZXNzYWdlcywgbm93LCBvbkVycm9yLCBwcmV2Q29udGV4dCwgdGltZVpvbmVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goSW50bENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VJbnRsQ29udGV4dCgpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoSW50bENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGludGwgY29udGV4dCBmb3VuZC4gSGF2ZSB5b3UgY29uZmlndXJlZCB0aGUgcHJvdmlkZXI/IFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9jb25maWd1cmF0aW9uI3NlcnZlci1jbGllbnQtY29tcG9uZW50cycgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxubGV0IGhhc1dhcm5lZEZvck1pc3NpbmdUaW1lem9uZSA9IGZhbHNlO1xuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIHVzZVRyYW5zbGF0aW9uc0ltcGwoYWxsTWVzc2FnZXNQcmVmaXhlZCwgbmFtZXNwYWNlUHJlZml4ZWQsIG5hbWVzcGFjZVByZWZpeCkge1xuICBjb25zdCB7XG4gICAgY2FjaGUsXG4gICAgZm9ybWF0czogZ2xvYmFsRm9ybWF0cyxcbiAgICBmb3JtYXR0ZXJzLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBsb2NhbGUsXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9ID0gdXNlSW50bENvbnRleHQoKTtcblxuICAvLyBUaGUgYG5hbWVzcGFjZVByZWZpeGAgaXMgcGFydCBvZiB0aGUgdHlwZSBzeXN0ZW0uXG4gIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgaG9vayBpbnZvY2F0aW9uLlxuICBjb25zdCBhbGxNZXNzYWdlcyA9IGFsbE1lc3NhZ2VzUHJlZml4ZWRbbmFtZXNwYWNlUHJlZml4XTtcbiAgY29uc3QgbmFtZXNwYWNlID0gcmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2VQcmVmaXhlZCwgbmFtZXNwYWNlUHJlZml4KTtcbiAgaWYgKCF0aW1lWm9uZSAmJiAhaGFzV2FybmVkRm9yTWlzc2luZ1RpbWV6b25lICYmIGlzU2VydmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWNvbXBpbGVyL3JlYWN0LWNvbXBpbGVyXG4gICAgaGFzV2FybmVkRm9yTWlzc2luZ1RpbWV6b25lID0gdHJ1ZTtcbiAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgYFRoZXJlIGlzIG5vIFxcYHRpbWVab25lXFxgIGNvbmZpZ3VyZWQsIHRoaXMgY2FuIGxlYWQgdG8gbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdDogaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVgICkpO1xuICB9XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlQmFzZVRyYW5zbGF0b3Ioe1xuICAgIGNhY2hlLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIG1lc3NhZ2VzOiBhbGxNZXNzYWdlcyxcbiAgICBuYW1lc3BhY2UsXG4gICAgb25FcnJvcixcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICB0aW1lWm9uZVxuICB9KSwgW2NhY2hlLCBmb3JtYXR0ZXJzLCBnZXRNZXNzYWdlRmFsbGJhY2ssIGFsbE1lc3NhZ2VzLCBuYW1lc3BhY2UsIG9uRXJyb3IsIGdsb2JhbEZvcm1hdHMsIGxvY2FsZSwgdGltZVpvbmVdKTtcbiAgcmV0dXJuIHRyYW5zbGF0ZTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIG1lc3NhZ2VzIGZyb20gdGhlIGdpdmVuIG5hbWVzcGFjZSBieSB1c2luZyB0aGUgSUNVIHN5bnRheC5cbiAqIFNlZSBodHRwczovL2Zvcm1hdGpzLmlvL2RvY3MvY29yZS1jb25jZXB0cy9pY3Utc3ludGF4LlxuICpcbiAqIElmIG5vIG5hbWVzcGFjZSBpcyBwcm92aWRlZCwgYWxsIGF2YWlsYWJsZSBtZXNzYWdlcyBhcmUgcmV0dXJuZWQuXG4gKiBUaGUgbmFtZXNwYWNlIGNhbiBhbHNvIGluZGljYXRlIG5lc3RpbmcgYnkgdXNpbmcgYSBkb3RcbiAqIChlLmcuIGBuYW1lc3BhY2UuQ29tcG9uZW50YCkuXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zbGF0aW9ucyhuYW1lc3BhY2UpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUludGxDb250ZXh0KCk7XG4gIGNvbnN0IG1lc3NhZ2VzID0gY29udGV4dC5tZXNzYWdlcztcblxuICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIGFjdHVhbCBob29rIHNvIHRoZSB0eXBlIGluZmVyZW5jZSBmb3IgdGhlIG9wdGlvbmFsXG4gIC8vIG5hbWVzcGFjZSB3b3JrcyBjb3JyZWN0bHkuIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gIC8vIFRoZSBwcmVmaXggKFwiIVwiKSBpcyBhcmJpdHJhcnkuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVXNlIHRoZSBleHBsaWNpdCBhbm5vdGF0aW9uIGluc3RlYWRcbiAgcmV0dXJuIHVzZVRyYW5zbGF0aW9uc0ltcGwoe1xuICAgICchJzogbWVzc2FnZXNcbiAgfSxcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBuYW1lc3BhY2UgPyBgIS4ke25hbWVzcGFjZX1gIDogJyEnLCAnIScpO1xufVxuXG5mdW5jdGlvbiB1c2VMb2NhbGUoKSB7XG4gIHJldHVybiB1c2VJbnRsQ29udGV4dCgpLmxvY2FsZTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm93KCkge1xuICByZXR1cm4gbmV3IERhdGUoKTtcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL2RhdGVzLXRpbWVzI3JlbGF0aXZlLXRpbWVzLXVzZW5vd1xuICovXG5mdW5jdGlvbiB1c2VOb3cob3B0aW9ucykge1xuICBjb25zdCB1cGRhdGVJbnRlcnZhbCA9IG9wdGlvbnM/LnVwZGF0ZUludGVydmFsO1xuICBjb25zdCB7XG4gICAgbm93OiBnbG9iYWxOb3dcbiAgfSA9IHVzZUludGxDb250ZXh0KCk7XG4gIGNvbnN0IFtub3csIHNldE5vd10gPSB1c2VTdGF0ZShnbG9iYWxOb3cgfHwgZ2V0Tm93KCkpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdXBkYXRlSW50ZXJ2YWwpIHJldHVybjtcbiAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgc2V0Tm93KGdldE5vdygpKTtcbiAgICB9LCB1cGRhdGVJbnRlcnZhbCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgfTtcbiAgfSwgW2dsb2JhbE5vdywgdXBkYXRlSW50ZXJ2YWxdKTtcbiAgcmV0dXJuIHVwZGF0ZUludGVydmFsID09IG51bGwgJiYgZ2xvYmFsTm93ID8gZ2xvYmFsTm93IDogbm93O1xufVxuXG5mdW5jdGlvbiB1c2VUaW1lWm9uZSgpIHtcbiAgcmV0dXJuIHVzZUludGxDb250ZXh0KCkudGltZVpvbmU7XG59XG5cbmZ1bmN0aW9uIHVzZU1lc3NhZ2VzKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlSW50bENvbnRleHQoKTtcbiAgaWYgKCFjb250ZXh0Lm1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXNzYWdlcyBmb3VuZC4gSGF2ZSB5b3UgY29uZmlndXJlZCB0aGVtIGNvcnJlY3RseT8gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL2NvbmZpZ3VyYXRpb24jbWVzc2FnZXMnICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQubWVzc2FnZXM7XG59XG5cbmZ1bmN0aW9uIHVzZUZvcm1hdHRlcigpIHtcbiAgY29uc3Qge1xuICAgIGZvcm1hdHMsXG4gICAgZm9ybWF0dGVycyxcbiAgICBsb2NhbGUsXG4gICAgbm93OiBnbG9iYWxOb3csXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9ID0gdXNlSW50bENvbnRleHQoKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBmb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICBub3c6IGdsb2JhbE5vdyxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lLFxuICAgIF9mb3JtYXR0ZXJzOiBmb3JtYXR0ZXJzXG4gIH0pLCBbZm9ybWF0cywgZm9ybWF0dGVycywgZ2xvYmFsTm93LCBsb2NhbGUsIG9uRXJyb3IsIHRpbWVab25lXSk7XG59XG5cbmZ1bmN0aW9uIGdldEFyZ3MobWVzc2FnZU9yUGFyYW1zLCAuLi5yZXN0KSB7XG4gIGxldCBtZXNzYWdlLCB2YWx1ZXMsIGZvcm1hdHM7XG4gIGlmICh0eXBlb2YgbWVzc2FnZU9yUGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlT3JQYXJhbXM7XG4gICAgdmFsdWVzID0gcmVzdFswXTtcbiAgICBmb3JtYXRzID0gcmVzdFsxXTtcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZU9yUGFyYW1zLm1lc3NhZ2U7XG4gICAgdmFsdWVzID0gbWVzc2FnZU9yUGFyYW1zLnZhbHVlcztcbiAgICBmb3JtYXRzID0gbWVzc2FnZU9yUGFyYW1zLmZvcm1hdHM7XG4gICAgLy8gYGRlc2NyaXB0aW9uYCBpcyBpcyBub3QgdXNlZCBhdCBydW50aW1lXG4gIH1cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBTZWNyZXQgZmFsbGJhY2sgcGFyYW1ldGVyXG4gIHJldHVybiBbdW5kZWZpbmVkLFxuICAvLyBBbHdheXMgdXNlIGZhbGxiYWNrIGlmIG5vdCBjb21waWxlZFxuICB2YWx1ZXMsIGZvcm1hdHMsIG1lc3NhZ2UgXTtcbn1cblxuLy8gTm90ZTogVGhpcyBBUEkgaXMgdXN1YWxseSBjb21waWxlZCBpbnRvIGB1c2VUcmFuc2xhdGlvbnNgLFxuLy8gYnV0IHRoZXJlIGlzIHNvbWUgZmFsbGJhY2sgaGFuZGxpbmcgd2hpY2ggYWxsb3dzIHRoaXMgaG9va1xuLy8gdG8gc3RpbGwgd29yayB3aGVuIG5vdCBiZWluZyBjb21waWxlZC5cbi8vXG4vLyBUaGlzIGlzIHJlbGV2YW50IGZvcjpcbi8vIC0gSXNvbGF0ZWQgZW52aXJvbm1lbnRzIGxpa2UgdGVzdHMsIFN0b3J5Ym9vaywgZXRjLlxuLy8gLSBGYWxsYmFja3MgaW4gY2FzZSBhbiBleHRyYWN0ZWQgbWVzc2FnZSBpcyBub3QgeWV0IGF2YWlsYWJsZVxuZnVuY3Rpb24gdXNlRXh0cmFjdGVkKG5hbWVzcGFjZSkge1xuICBjb25zdCB0ID0gdXNlVHJhbnNsYXRpb25zKG5hbWVzcGFjZSk7XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUZuKC4uLnBhcmFtcykge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUGFzc2luZyBgdW5kZWZpbmVkYCBhcyBhbiBJRCBpcyBzZWNyZXRseSBhbGxvd2VkIGhlcmVcbiAgICByZXR1cm4gdCguLi5nZXRBcmdzKC4uLnBhcmFtcykpO1xuICB9XG4gIHRyYW5zbGF0ZUZuLnJpY2ggPSAoLi4ucGFyYW1zKSA9PlxuICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFBhc3NpbmcgYHVuZGVmaW5lZGAgYXMgYW4gSUQgaXMgc2VjcmV0bHkgYWxsb3dlZCBoZXJlXG4gIHQucmljaCguLi5nZXRBcmdzKC4uLnBhcmFtcykpO1xuICB0cmFuc2xhdGVGbi5tYXJrdXAgPSAoLi4ucGFyYW1zKSA9PlxuICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFBhc3NpbmcgYHVuZGVmaW5lZGAgYXMgYW4gSUQgaXMgc2VjcmV0bHkgYWxsb3dlZCBoZXJlXG4gIHQubWFya3VwKC4uLmdldEFyZ3MoLi4ucGFyYW1zKSk7XG4gIHRyYW5zbGF0ZUZuLmhhcyA9IGZ1bmN0aW9uIHRyYW5zbGF0ZUhhc0ZuKFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIG1lc3NhZ2UpIHtcbiAgICAvLyBOb3QgcmVhbGx5IHNvbWV0aGluZyBiZXR0ZXIgd2UgY2FuIGRvIGhlcmVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zbGF0ZUZuO1xufVxuXG5leHBvcnQgeyBJbnRsUHJvdmlkZXIsIHVzZUV4dHJhY3RlZCBhcyBfdXNlRXh0cmFjdGVkLCB1c2VGb3JtYXR0ZXIsIHVzZUxvY2FsZSwgdXNlTWVzc2FnZXMsIHVzZU5vdywgdXNlVGltZVpvbmUsIHVzZVRyYW5zbGF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlTWVtbyIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZCIsImNyZWF0ZUNhY2hlIiwiYiIsImNyZWF0ZUludGxGb3JtYXR0ZXJzIiwiaSIsImluaXRpYWxpemVDb25maWciLCJyIiwicmVzb2x2ZU5hbWVzcGFjZSIsIkkiLCJJbnRsRXJyb3IiLCJhIiwiSW50bEVycm9yQ29kZSIsImUiLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsImMiLCJjcmVhdGVGb3JtYXR0ZXIiLCJqc3giLCJJbnRsQ29udGV4dCIsInVuZGVmaW5lZCIsIkludGxQcm92aWRlciIsImNoaWxkcmVuIiwiZm9ybWF0cyIsImdldE1lc3NhZ2VGYWxsYmFjayIsImxvY2FsZSIsIm1lc3NhZ2VzIiwibm93Iiwib25FcnJvciIsInRpbWVab25lIiwicHJldkNvbnRleHQiLCJjYWNoZSIsImZvcm1hdHRlcnMiLCJ2YWx1ZSIsIlByb3ZpZGVyIiwidXNlSW50bENvbnRleHQiLCJjb250ZXh0IiwiRXJyb3IiLCJoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUiLCJpc1NlcnZlciIsInVzZVRyYW5zbGF0aW9uc0ltcGwiLCJhbGxNZXNzYWdlc1ByZWZpeGVkIiwibmFtZXNwYWNlUHJlZml4ZWQiLCJuYW1lc3BhY2VQcmVmaXgiLCJnbG9iYWxGb3JtYXRzIiwiYWxsTWVzc2FnZXMiLCJuYW1lc3BhY2UiLCJFTlZJUk9OTUVOVF9GQUxMQkFDSyIsInRyYW5zbGF0ZSIsInVzZVRyYW5zbGF0aW9ucyIsInVzZUxvY2FsZSIsImdldE5vdyIsIkRhdGUiLCJ1c2VOb3ciLCJvcHRpb25zIiwidXBkYXRlSW50ZXJ2YWwiLCJnbG9iYWxOb3ciLCJzZXROb3ciLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidXNlVGltZVpvbmUiLCJ1c2VNZXNzYWdlcyIsInVzZUZvcm1hdHRlciIsIl9mb3JtYXR0ZXJzIiwiZ2V0QXJncyIsIm1lc3NhZ2VPclBhcmFtcyIsInJlc3QiLCJtZXNzYWdlIiwidmFsdWVzIiwidXNlRXh0cmFjdGVkIiwidCIsInRyYW5zbGF0ZUZuIiwicGFyYW1zIiwicmljaCIsIm1hcmt1cCIsImhhcyIsInRyYW5zbGF0ZUhhc0ZuIiwiX3VzZUV4dHJhY3RlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/esm/development/react.js\n");

/***/ })

};
;